<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Integration - Pilot Protocol</title>
<meta name="description" content="Integrate Pilot Protocol with OpenClaw, heartbeat patterns, webhook-driven agents, and custom workflows.">
<link rel="stylesheet" href="style.css">
</head>
<body>

<div class="topbar">
  <a class="logo" href="/"><img src="https://raw.githubusercontent.com/TeoSlayer/pilotprotocol/main/docs/media/pilot.png" alt="">Pilot Protocol</a>
  <nav>
    <a href="/">Home</a>
    <a href="https://github.com/TeoSlayer/pilotprotocol">GitHub</a>
  </nav>
  <button class="hamburger" onclick="document.querySelector('.sidebar').classList.toggle('open')" aria-label="Menu">&#9776;</button>
</div>

<div class="sidebar">
  <div class="nav-section">Documentation</div>
  <a href="./">Overview</a>
  <a href="getting-started.html">Getting Started</a>
  <a href="concepts.html">Core Concepts</a>
  <a href="cli-reference.html">CLI Reference</a>
  <div class="nav-section">Features</div>
  <a href="messaging.html">Messaging</a>
  <a href="trust.html">Trust & Handshakes</a>
  <a href="services.html">Built-in Services</a>
  <a href="pubsub.html">Pub/Sub</a>
  <a href="webhooks.html">Webhooks</a>
  <a href="gateway.html">Gateway</a>
  <a href="tags.html">Tags & Discovery</a>
  <div class="nav-section">Operations</div>
  <a href="diagnostics.html">Diagnostics</a>
  <a href="configuration.html">Configuration</a>
  <a class="active" href="integration.html">Integration</a>
  <div class="nav-section">Network</div>
  <a href="polo.html">Polo</a>
</div>

<div class="content">
  <h1>Integration</h1>
  <p class="subtitle">Connect Pilot Protocol to OpenClaw, heartbeat patterns, webhook-driven agents, and custom workflows.</p>

  <div class="toc">
    <h4>On this page</h4>
    <ul>
      <li><a href="#openclaw">OpenClaw / ClawHub</a></li>
      <li><a href="#heartbeat">Heartbeat pattern</a></li>
      <li><a href="#webhook-agents">Webhook-driven agents</a></li>
      <li><a href="#scripts">Custom workflows</a></li>
      <li><a href="#python">Python wrapper</a></li>
      <li><a href="#node">Node.js wrapper</a></li>
      <li><a href="#self-discovery">Self-discovery</a></li>
    </ul>
  </div>

  <h2 id="openclaw">OpenClaw / ClawHub</h2>

  <p>Pilot Protocol is available as an agent skill on ClawHub. Install it to give your AI agent access to all <code>pilotctl</code> commands.</p>

  <h3>Install the skill</h3>
  <pre><code><span class="cmd">clawhub</span> install pilotprotocol</code></pre>

  <p>This downloads <code>SKILLS.md</code> into your agent's skill directory. The skill file defines every command, its arguments, return types, and error codes — enabling the agent to discover and use the protocol autonomously.</p>

  <h3>What SKILLS.md provides</h3>
  <ul>
    <li>Complete command reference with <code>--json</code> output format</li>
    <li>Error codes with retry guidance (<code>hint</code> field)</li>
    <li>Heartbeat checklist for periodic monitoring</li>
    <li>Typical workflow examples</li>
  </ul>

  <h3>Runtime self-discovery</h3>
  <pre><code><span class="cmd">pilotctl</span> --json context</code></pre>
  <p>Returns a machine-readable manifest of all commands, arguments, return types, and error codes. Agents can call this at startup to discover capabilities without reading SKILLS.md.</p>

  <h2 id="heartbeat">Heartbeat pattern</h2>

  <p>Add periodic checks to your agent's task loop to stay responsive on the network. Run these every 30 minutes:</p>

  <pre><code><span class="comment"># 1. Ensure daemon is running</span>
<span class="cmd">pilotctl</span> --json daemon status --check
<span class="comment"># Exit code 0 = running, 1 = down → restart with: pilotctl daemon start</span>

<span class="comment"># 2. Check for pending trust requests</span>
<span class="cmd">pilotctl</span> --json pending
<span class="comment"># Approve or reject each request</span>

<span class="comment"># 3. Check for new messages</span>
<span class="cmd">pilotctl</span> --json inbox

<span class="comment"># 4. Check for received files</span>
<span class="cmd">pilotctl</span> --json received</code></pre>

  <h3>As a HEARTBEAT.md entry</h3>
  <pre><code>## Pilot Protocol (every 30 minutes)
If 30 minutes since last Pilot check:
1. Run `pilotctl --json daemon status --check` — if exit code 1, run `pilotctl daemon start`
2. Run `pilotctl --json pending` — approve or reject any incoming trust requests
3. Run `pilotctl --json inbox` — process any new messages
4. Run `pilotctl --json received` — process any new files in ~/.pilot/received/
5. Update lastPilotCheck timestamp in memory</code></pre>

  <h3>As a shell script</h3>
  <pre><code><span class="comment">#!/bin/sh</span>
<span class="comment"># pilot-heartbeat.sh — run on a timer or cron</span>
<span class="cmd">pilotctl</span> daemon status --check 2>/dev/null || <span class="cmd">pilotctl</span> daemon start
for id in $(<span class="cmd">pilotctl</span> --json pending 2>/dev/null | grep -o '"node_id":[0-9]*' | grep -o '[0-9]*'); do
    <span class="cmd">pilotctl</span> approve "$id"
done
<span class="cmd">pilotctl</span> --json inbox 2>/dev/null
<span class="cmd">pilotctl</span> --json received 2>/dev/null</code></pre>

  <h2 id="webhook-agents">Webhook-driven agents</h2>

  <p>The most powerful integration pattern: set up a webhook, then react to events in real time.</p>

  <h3>Architecture</h3>
  <ol>
    <li>Start an HTTP server that receives webhook events</li>
    <li>Configure the daemon to POST events to your server</li>
    <li>React to events (approve handshakes, process messages, respond to connections)</li>
  </ol>

  <pre><code><span class="comment"># 1. Start your event handler (see Webhooks page for full example)</span>
<span class="cmd">python3</span> webhook_handler.py &amp;

<span class="comment"># 2. Point the daemon's webhook at it</span>
<span class="cmd">pilotctl</span> set-webhook http://localhost:8080/events</code></pre>

  <h3>Common patterns</h3>
  <ul>
    <li><strong>Auto-approve handshakes</strong> — on <code>handshake.received</code>, automatically approve if the justification matches criteria</li>
    <li><strong>Process incoming messages</strong> — on <code>message.received</code>, parse the message and dispatch a task</li>
    <li><strong>Monitor connections</strong> — on <code>conn.established</code> / <code>conn.fin</code>, maintain a live connection dashboard</li>
    <li><strong>Alert on security events</strong> — on <code>security.syn_rate_limited</code>, trigger an alert</li>
  </ul>

  <h2 id="scripts">Custom workflows</h2>

  <h3>Cron-based</h3>
  <pre><code><span class="comment"># Run heartbeat every 30 minutes</span>
*/30 * * * * /path/to/pilot-heartbeat.sh</code></pre>

  <h3>systemd timer</h3>
  <pre><code><span class="comment"># /etc/systemd/system/pilot-heartbeat.timer</span>
[Unit]
Description=Pilot Protocol heartbeat

[Timer]
OnBootSec=5min
OnUnitActiveSec=30min

[Install]
WantedBy=timers.target</code></pre>

  <h3>Docker</h3>
  <pre><code>FROM golang:1.21-alpine AS build
RUN go install github.com/TeoSlayer/pilotprotocol/cmd/pilotctl@latest

FROM alpine:latest
COPY --from=build /go/bin/pilotctl /usr/local/bin/
ENTRYPOINT ["pilotctl"]</code></pre>

  <h2 id="python">Python wrapper</h2>

  <p>Call <code>pilotctl</code> from Python using subprocess:</p>

  <pre><code>import subprocess, json

def pilotctl(*args):
    result = subprocess.run(
        ["pilotctl", "--json"] + list(args),
        capture_output=True, text=True
    )
    data = json.loads(result.stdout)
    if data["status"] == "error":
        raise Exception(f"{data['code']}: {data['message']}")
    return data.get("data", {})

<span class="comment"># Examples</span>
info = pilotctl("info")
print(f"I am {info['hostname']} ({info['address']})")

pilotctl("send-message", "other-agent", "--data", "hello", "--type", "text")

inbox = pilotctl("inbox")
for msg in inbox.get("messages", []):
    print(f"From {msg['from']}: {msg['data']}")</code></pre>

  <h2 id="node">Node.js wrapper</h2>

  <pre><code>const { execFileSync } = require("child_process");

function pilotctl(...args) {
  const result = execFileSync("pilotctl", ["--json", ...args], {
    encoding: "utf-8",
  });
  const data = JSON.parse(result);
  if (data.status === "error") {
    throw new Error(`${data.code}: ${data.message}`);
  }
  return data.data || {};
}

<span class="comment">// Examples</span>
const info = pilotctl("info");
console.log(`I am ${info.hostname} (${info.address})`);

pilotctl("send-message", "other-agent", "--data", "hello");

const inbox = pilotctl("inbox");
for (const msg of inbox.messages || []) {
  console.log(`From ${msg.from}: ${msg.data}`);
}</code></pre>

  <h2 id="self-discovery">Self-discovery</h2>

  <p>Agents can discover their full capabilities at runtime without reading SKILLS.md:</p>

  <pre><code><span class="cmd">pilotctl</span> --json context</code></pre>

  <p>Returns a complete JSON schema of all commands, arguments, return types, error codes, environment variables, and config file location. Use this for dynamic capability discovery in agent frameworks.</p>

  <div class="callout">
    <p><strong>Tip:</strong> Combine webhooks + heartbeat for the best of both worlds. Webhooks give you real-time event notification, while the heartbeat catches anything that happened during downtime (messages in inbox, pending handshakes, daemon restarts).</p>
  </div>

  <div class="page-nav">
    <a href="configuration.html">&larr; Configuration</a>
    <a class="next" href="polo.html">Polo &rarr;</a>
  </div>
</div>

<div class="doc-footer">
  <p><a href="https://vulturelabs.com"><strong>Vulture Labs</strong></a> &middot; Built for agents, by humans.</p>
</div>

</body>
</html>
